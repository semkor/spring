https://russianblogs.com/article/76911240797/ - доп источник

https://coderlessons.com/articles/java/rukovodstvo-po-annotatsiiam-spring-framework


-------------------------------------Основные Spring Framework Аннотации------------------------------------------------
1.1 - @Required
        Применяется к методам установки бинов.
        Рассмотрим сценарий, в котором вам нужно применить обязательное свойство.
            Аннотацию указывает на то, что пострадавшее компонент должен быть заполнен во время конфигурации с требуемым свойством.
            В противном случае создается исключение типа  BeanInitializationException.

1.2 - @Autowired
        Применяется к полям, сеттерам и конструкторам.
        В  @Autowired аннотации впрыскивает объект зависимости неявно.

1.3 - @Qualifier
        Используется вместе с  @Autowired аннотацией.
        Используется, чтобы избежать путаницы, которая возникает, когда вы создаете несколько бинов одного
   типа и хотите связать только один из них со свойством.
        @Qualifier может быть указано в отдельных аргументах конструктора или параметрах метода.
            Рассмотрим пример, где интерфейс  BeanInterface реализуется двумя bean-компонентами, BeanB1 и BeanB2.
                    @Component
                    public class BeanB1 implements BeanInterface {
                            //
                    }
                    @Component
                    public class BeanB2 implements BeanInterface {
                            //
                    }
            Теперь, если BeanA автоматически подключит этот интерфейс, Spring не будет знать, какую из двух реализаций внедрить.
            Одним из решений этой проблемы является использование  @Qualifier аннотации.
                    @Component
                    public class BeanA {
                        @Autowired
                        @Qualifier("beanB2")
                        private IBean dependency;
                     }
            С  @Qualifier добавленной аннотацией Spring теперь будет знать, какой bean-компонент нужно связать автоматически,
        а где  beanB2 имя BeanB2.

1.4 - @Configuration
        Используется для классов, которые определяют bean-компоненты.
        @Configuration является аналогом файла конфигурации XML — он настраивается с использованием классов Java.
        Класс Java с  @Configuration пометкой сам по себе является конфигурацией и будет иметь методы для создания
   экземпляров и настройки зависимостей.
        Пример:
            @Configuartion
            public class DataConfig {
                @Bean
                public DataSource source() {
                    DataSource source = new OracleDataSource();
                    source.setURL();
                    source.setUser();
                    return source;
                }

                @Bean
                public PlatformTransactionManager manager() {
                    PlatformTransactionManager manager = new BasicDataSourceTransactionManager();
                    manager.setDataSource(source());
                    return manager;
                }
            }

1.5 - @ComponentScan
        Используется вместе с @Configuration аннотацией, чтобы Spring знал, какие пакеты сканируются для аннотированных компонентов.
        @ComponentScan также используется для указания использования базовых пакетов  basePackageClasses или  basePackage
   атрибутов для сканирования.
        Если конкретные пакеты не определены, сканирование будет выполняться из пакета класса, который объявляет эту аннотацию.

1.6 - @Bean
        Используется на уровне метода.
        @Bean совместно  @Configuration создает бины проекта
        Как упоминалось ранее,  @Configuration  будут иметь методы для создания экземпляров и настройки зависимостей.
        Такие методы будут аннотированы  @Bean.
        Метод, аннотированный этой аннотацией, работает как идентификатор компонента, а также создает и возвращает фактический компонент.
        Пример:
                @Configuration
                public class AppConfig {
                    @Bean
                    public Person person() {
                        return new Person(address());
                    }

                    @Bean
                    public Address address() {
                        return new Address();
                    }
                }

1.7 - @Lazy
        Используется для классов компонентов.
        По умолчанию все автосвязные зависимости создаются и настраиваются при запуске.
        Но если вы хотите лениво инициализировать бин, вы можете использовать  @Lazy аннотацию над классом.
        Это означает, что bean-компонент будет создан и инициализирован только при первом запросе.
        Также можно использовать эту аннотацию на  @Configuration классах.
            - это указывает на то, что все  @Bean методы в пределах этого  @Configuration должны быть лениво инициализированы.

1.8 - @Value
        Используется на уровнях поля, параметра конструктора и параметра метода.
        Указывает выражение на значение по умолчанию для поля или параметра , чтобы инициализировать свойство с.
        Так как @Autowired аннотация говорит Spring, чтобы внедрить объект в другой при загрузке контекста приложения,
    вы также можете использовать @Value аннотацию для вставки значений из файла свойств в атрибут компонента.
        Он поддерживает заполнители # {…} и $ {…} .

------------------------------------------------------------------------------------------------------------------------
2.0 - @Component
        Используется в классах для обозначения компонента Spring.
        В @Component аннотации помечает класс Java.

2.1 - @Controller
        Используется для указания какой класс играют роль контроллера в вашем приложении.
        Чтобы включить автоматическое обнаружение таких аннотированных контроллеров, можете добавить компонентное сканирование
    в вашу конфигурацию.
        Класс Java с @Controller  способен обрабатывать несколько сопоставлений запросов.
        Эта аннотация может использоваться для идентификации контроллеров для Spring MVC или Spring WebFlux.

2.2 - @Service
        Используется в классе.
        @Service помечает класс Java, который выполняет некоторую услугу, такую как выполнение бизнес-логики,
        выполнение вычислений и вызов внешних API.
        Эта аннотация является специализированной формой  @Component аннотации, предназначенной для использования на сервисном уровне.

2.3 - @Repository
        Используется в классах Java, которые напрямую обращаются к базе данных.
        В  @Repository аннотации работает как маркер для любого класса , который выполняет роль хранилища или доступ к данным объекта.
        Эта аннотация имеет функцию автоматического перевода.
            Например:
                - когда возникает исключение в  @Repository, существует обработчик для этого исключения,  и нет необходимости
            добавлять блок try-catch.

---------------------------------------- Spring MVC и REST Аннотации ---------------------------------------------------

3.1.0 - @RequestMapping
        Используется как на уровне класса, так и на уровне метода.
        Используется для отображения веб — запросов на конкретные классы обработчиков и обработчиков методов.
            - когда используется на уровне класса, он создает базовый URI, для которого будет использоваться контроллер.
            - когда используется для методов, она выдаст вам URI, для которого будут выполняться методы-обработчики.
        Отсюда можно сделать вывод, что сопоставление запросов на уровне класса останется прежним, тогда как у каждого метода-обработчика
   будет свое сопоставление запросов.
        Иногда вам может потребоваться выполнить различные операции в зависимости от используемого метода HTTP, даже если URI запроса
   может оставаться прежним.
        В таких ситуациях вы можете использовать атрибут  @RequestMapping метода со значением метода HTTP, чтобы сузить методы
   HTTP для вызова методов вашего класса.
        Вот базовый пример того, как работает контроллер вместе с отображениями запросов:
                @Controller
                @RequestMapping("/welcome")
                public class WelcomeController {

                    @RequestMapping(method = RequestMethod.GET)
                    public String welcomeAll() {
                        return "welcome all";
                    }
                }
        В этом примере  метод /welcome обрабатывает  только запросы GET welcomeAll().
        Эта аннотация также может использоваться с Spring MVC и Spring WebFlux.

3.1.1 - @GetMapping
        Используется для отображения запросов HTTP GET на определенные методы-обработчики.
        @GetMapping это составная аннотация, которая действует как ярлык для @RequestMapping(method = RequestMethod.GET).

3.1.2 - @PostMapping
        Используется для отображения запросов HTTP POST на определенные методы-обработчики.
        @PostMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.POST).

3.1.3 - @PutMapping
        Используется для отображения запросов HTTP PUT на определенные методы-обработчики.
        @PutMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.PUT).

3.1.4 - @PatchMapping
        Используется для отображения запросов HTTP PATCH на определенные методы-обработчики.
        @PatchMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.PATCH).

3.1.5 - @DeleteMapping
        Используется для отображения запросов HTTP DELETE на определенные методы-обработчики.
        @DeleteMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.DELETE).

3.2 - @CookieValue
        Используется на уровне параметров метода.
        Используется в качестве аргумента метода отображения запроса.
        Файл cookie HTTP связан с  @CookieValue параметром для данного имени файла cookie.
        Эта аннотация используется в методе, аннотированном с помощью   @RequestMapping.
            Давайте рассмотрим, что следующее значение cookie получено с HTTP-запросом  JSESSIONID=418AB76CD83EF94U85YD34W
                Чтобы получить значение cookie, используйте @CookieValue следующим образом:
                    @ReuestMapping("/cookieValue")
                    public void getCookieValue(@CookieValue "JSESSIONID" String cookie){}

3.3 - @CrossOrigin
        Используется как на уровне класса, так и на уровне метода для разрешения запросов между источниками.
        Во многих случаях хост, обслуживающий JavaScript, будет отличаться от хоста, обслуживающего данные.
        В таком случае кросс-ресурсное совместное использование ресурсов (CORS) обеспечивает междоменную связь.
        Чтобы включить эту связь, вам просто нужно добавить  @CrossOrigin  аннотацию.
        По умолчанию  @CrossOrigin аннотация допускает все происхождение, все заголовки, методы HTTP,
    указанные в  @RequestMapping аннотации, и maxAge 30 мин.
        Вы можете настроить поведение, указав соответствующие значения атрибута.
            Пример использования  @CrossOrigin на уровне методов контроллера и обработчика приведен ниже:

                @CrossOrigin(maxAge = 3600)
                @RestController
                @RequestMapping("/account")
                public class AccountController {

                    @CrossOrigin(origins = "http://example.com")
                    @RequestMapping("/message")
                    public Message getMessage() {
                            // ...
                    }

                    @RequestMapping("/note")
                    public Note getNote() {
                            // ...
                    }
                }
            В этом примере, как  getExample() и  getNote() методы будут иметь MaxAge 3600 секунд.
            Кроме того, getExample() будут разрешены только запросы о происхождении с сайта http://example.com,
                     а  getNote() запросы всех источников — со всех узлов.

3.4 - @ExceptionHandler
            Используется на уровнях метода для обработки исключений на уровне контроллера.
            @ExceptionHandler Аннотаций используется для определения класса исключения он будет ловить.
            Вы можете использовать эту аннотацию для методов, которые должны вызываться для обработки исключения.
            Эти  @ExceptionHandler значения могут быть установлены в массив типов исключений.
            Если выдается исключение, которое соответствует одному из типов в списке, то @ExceptionHandler будет вызван метод,
            аннотированный с сопоставлением  .

3.5 - @InitBinder
            Эта аннотация является аннотацией уровня метода, которая играет роль идентификации методов,
            которые инициализируют -a  WebDataBinder ,  DataBinder который связывает параметр запроса с объектами JavaBean.
            Чтобы настроить привязку данных параметров запроса, вы можете использовать  @InitBinder аннотированные методы в нашем
            контроллере. Методы, отмеченные как,  @InitBinder включают все типы аргументов, которые поддерживаются методами-обработчиками.

В  @InitBinder аннотированные методы будут вызываться для каждого запроса HTTP , если не указать значение элемента этой аннотации.
Элементом value может быть одно или несколько имен форм или параметров запроса, к которым применяется метод привязки init.

3.6 - @Mappings и @Mapping
        Используется на полях.
        @Mapping Аннотаций является мета-аннотаций , что указывает на веб — отображение аннотацию.
        При отображении разных имен полей необходимо настроить исходное поле на его целевое поле, и для этого необходимо
        добавить  @Mappings аннотацию. Эта аннотация принимает массив  @Mapping с исходными и целевыми полями.

3.7 - @MatrixVariable
        Используется для аннотирования аргументов метода обработчика запросов, чтобы Spring мог внедрить соответствующие биты матричного URI.
        Матричные переменные могут появляться в любом сегменте, каждый из которых разделен точкой с запятой.
        Если URL-адрес содержит матричные переменные, шаблон отображения запроса должен представлять их с помощью шаблона URI.
        @MatrixVariable Аннотацию гарантирует , что запрос соответствует с правильным матричным переменной URI.

3.8 - @PathVariable
        Используется для аннотирования аргументов метода обработчика запроса.
        @RequestMapping Аннотации могут быть использованы для обработки динамических изменений в URI , где определенное значение URI , действует в качестве параметра.
        Вы можете указать этот параметр с помощью регулярного выражения.
        @PathVariable Аннотации могут быть использованы для объявления этого параметра.

3.9 - @RequestAttribute
        Используется для привязки атрибута запроса к параметру метода обработчика.
        Spring получает значение именованного атрибута, чтобы заполнить параметр, отмеченный @RequestAttribute.
        Хотя  @RequestParamannotation используется для связывания значений параметров из строки запроса,
        @RequestAttribute  используется для доступа к объектам, которые были заполнены на стороне сервера.

3.10 - @RequestBody
        Используется для аннотирования аргументов метода обработчика запроса.
        @RequestBody Аннотации указывает на то, что параметр метод должен быть связан с величиной тела запроса HTTP.
        HttpMessageConveter Отвечает за преобразование из сообщения запроса HTTP на объект.

3.11 - @RequestHeader
        Используется для аннотирования аргументов метода обработчика запроса.
        @RequestHeader Аннотаций используется для отображения параметра контроллера к значению заголовка запроса.
        Когда Spring отображает запрос,  @RequestHeader проверяет заголовок с именем, указанным в аннотации,
        и связывает его значение с параметром метода-обработчика.
        Эта аннотация поможет вам получить подробности заголовка в классе контроллера.

3.12 - @RequestParam
        Используется для аннотирования аргументов метода обработчика запроса.
        Иногда вы получаете параметры в URL запроса, в основном в запросах GET.
        В этом случае, наряду с  @RequestMapping аннотацией, вы можете использовать  @RequestParam аннотацию,
        чтобы получить параметр URL и сопоставить его с аргументом метода.
        @RequestParam Аннотаций используется для связывания параметров запроса с параметром метода в контроллере.

3.13 - @RequestPart
        Используется для аннотирования аргументов метода обработчика запроса.
        @RequestPart Аннотаций может быть использован вместо  того @RequestParam чтобы получить
        содержание конкретного многоголосных и привязать его к аргументу методы аннотации   @RequestPart.
        Эта аннотация учитывает заголовок «Content-Type» в составной части (часть запроса).

3.14 - @ResponseBody
        Используется для аннотирования методов обработчика запросов.
        @ResponseBody Аннотация похожа на  @RequestBody аннотацию.
        @ResponseBody Аннотацию указывает на то, что тип результата должен быть записан прямо в теле ответа в любом формате ,
        вы указываете , как JSON или XML. Spring преобразует возвращаемый объект в тело ответа, используя  HttpMessageConveter.

3.15 - @ResponseStatus
        Используется для методов и классов исключений.
        @ResponseStatus помечает метод или класс исключений кодом состояния и причиной, которая должна быть возвращена.
        Когда вызывается метод-обработчик, для кода состояния устанавливается HTTP-ответ, который переопределяет информацию о состоянии,
        предоставленную любыми другими средствами.
        Класс контроллера также может быть аннотирован   @ResponseStatus, который затем наследуется всеми  @RequestMapping методами.

3.16 - @ControllerAdvice
        Применяется на уровне класса.
        Как объяснялось ранее, для каждого контроллера вы можете использовать  @ExceptionHandler метод,
    который будет вызываться при возникновении данного исключения.
        Но это обрабатывает только те исключения, которые происходят в контроллере, в котором он определен.
        Чтобы преодолеть эту проблему, теперь вы можете использовать  @ControllerAdvice аннотацию.
        Это примечание используется для определения @ExceptionHandler, @InitBinderи  @ModelAttribute методы ,
    которые применяются ко всем  @RequestMapping методам.
        Таким образом, если вы определите  @ExceptionHandler аннотацию для метода в   @ControllerAdvice классе,
    она будет применена ко всем контроллерам.

3.17 - @RestController
        Используется на уровне класса.
        В  @RestController аннотации класс исполняется в качестве контроллера , где каждый метод возвращает
        объект домена вместо зрения. Аннотируя класс этой аннотацией, вам больше не нужно добавлять  @ResponseBody все  RequestMapping методы.
        Это означает, что вы больше не используете средства разрешения представления или не отправляете HTML в ответ.
        Вы просто отправляете объект домена в виде HTTP-ответа в формате, понятном потребителям, например JSON.
        @RestController  это удобная аннотация, которая сочетает в себе  @Controller и   @ResponseBody.

3.18 - @RestControllerAdvice
        Применяется к классам Java. @RestControllerAdvice это удобная аннотация,
        которая сочетает в себе  @ControllerAdvice и @ResponseBody.
        Эта аннотация используется вместе с  @ExceptionHandler аннотацией для обработки исключений, возникающих в контроллере.

3.19 - @SessionAttribute
        Эта аннотация используется на уровне параметров метода.
        @SessionAttribute Аннотаций используется для связывания параметра метода в атрибут сеанса.
        Эта аннотация обеспечивает удобный доступ к существующим или постоянным атрибутам сеанса.

3.20 - @SessionAttributes
        Эта аннотация применяется на уровне типа для определенного обработчика.
        @SessionAtrributes Аннотаций используется , когда вы хотите добавить JavaBean объекта в сессию.
        Это используется, когда вы хотите сохранить объект в сеансе на короткое время.
        @SessionAttributes используется в сочетании с @ModelAttribute.

        Рассмотрим этот пример:
            @ModelAttribute("person")
            public Person getPerson() {}
                    // within the same controller as above snippet

            @Controller
            @SeesionAttributes(value = "person", types = {
            Person.class
})
            public class PersonController {}
@ModelAttribute Имя присваивается в  @SessionAttributes качестве значения.
@SessionAttributes Состоит из двух элементов.
Элемент value — это имя сеанса в модели, а элемент types — это тип атрибутов сеанса в модели.

------------------------------------- Spring Framework DataAccess Аннотации --------------------------------------------

10 - @Transactional
Эта аннотация помещается перед определением интерфейса, методом на интерфейсе, определением класса или открытым методом на классе. Простого присутствия  @Transactional недостаточно для активации транзакционного поведения. Это  @Transactional просто метаданные, которые могут использоваться некоторой инфраструктурой времени выполнения. Эта инфраструктура использует метаданные для настройки соответствующих компонентов с поведением транзакций.

Аннотация также поддерживает конфигурацию, такую ​​как:

Тип распространения транзакции
Уровень изоляции транзакции
Тайм-аут для операции, завернутой транзакцией
Флаг только для чтения — подсказка поставщику постоянства, что транзакция должна быть только для чтения. Правила отката для транзакции.

------------------------------------------- Spring Cloud Аннотации ----------------------------------------------------

11.1 - @EnableConfigServer
Эта аннотация используется на уровне класса. При разработке проекта с несколькими службами вам необходимо иметь централизованный и простой способ настройки и извлечения конфигураций всех служб, которые вы собираетесь разрабатывать. Одним из преимуществ использования централизованного сервера конфигурации является то, что вам не нужно нести бремя запоминания того, где каждая конфигурация распределена по нескольким и распределенным компонентам.

Вы можете использовать @EnableConfigServer аннотацию Spring Cloud  для запуска сервера конфигурации, с которым могут общаться другие приложения.

11.2 - @EnableEurekaServer
Эта аннотация применяется к классам Java. Одна из проблем, с которой вы можете столкнуться при декомпозиции вашего приложения на микросервисы, заключается в том, что каждому сервису становится трудно узнать адрес каждого другого сервиса, от которого он зависит. Приходит служба обнаружения, которая отвечает за отслеживание местоположения всех других микросервисов.

Eureka от Netflix является реализацией сервера обнаружения, а интеграция обеспечивается Spring Boot. Spring Boot упростил проектирование сервера Eureka, просто пометив начальный класс с помощью   @EnableEurekaServer.

11.3 - @EnableDiscoveryClient
Эта аннотация применяется к классам Java. Чтобы указать любому приложению регистрироваться в Eureka, вам просто нужно добавить  @EnableDiscoveryClient аннотацию к точке входа приложения. Приложение, которое теперь зарегистрировано в Eureka, использует абстракцию клиента Spring Cloud Discovery для опроса реестра для своего собственного хоста и порта.

11.4 - @EnableCircuitBreaker
Эта аннотация применяется к классам Java, которые могут действовать как прерыватель цепи. Схема автоматического выключателя может позволить микросервису продолжать работу при сбое связанной службы, предотвращая каскадный сбой. Это также дает сбойному сервису время для восстановления.

Класс с пометкой  @EnableCircuitBreaker  будет контролировать, размыкать и замыкать автоматический выключатель.

11.5 - @HystrixCommand
Эта аннотация используется на уровне метода. Библиотека Hyfrix от Netflix обеспечивает реализацию шаблона прерывателя цепи. Когда вы применяете автоматический выключатель к методу, Hystrix отслеживает сбои метода. Как только сбои нарастают до порогового значения, Hystrix открывает канал, так что последующие вызовы также не срабатывают. Теперь Hystrix перенаправляет вызовы метода, и они передаются указанным резервным методам.

Hystrix ищет любой метод, аннотированный  @HystrixCommand аннотацией, и помещает его в прокси-сервер, подключенный к автоматическому выключателю, чтобы Hystrix мог отслеживать его.

Рассмотрим следующий пример:

@Service
public class BookService {
    private final RestTemplate restTemplate;
    public BookService(RestTemplate rest) {
        this.restTemplate = rest;
    }
    @HystrixCommand(fallbackMethod = "newList") public String bookList() {
        URI uri = URI.create("http://localhost:8081/recommended");
        return this.restTemplate.getForObject(uri, String.class);
    }
    public String newList() {
        return "Cloud native Java";
    }
}
Здесь  @HystrixCommand применяется оригинальный метод   bookList(). У  @HystrixCommand  аннотации есть  newList запасной метод. Поэтому, по какой-то причине, если Hystrix откроет канал   bookList(), у вас будет список заполненных книг, готовый для пользователей.


------------------------------------------- Аннотации на основе кэша ---------------------------------------------------

12.1 - @Cacheable
Эта аннотация используется для методов. Самый простой способ включить поведение кеша для метода — это пометить его  @Cacheable и параметризировать его именем кеша, в котором будут храниться результаты.

12.2 - @Cacheable("addresses")
public String getAddress(Book book){...}
В приведенном выше фрагменте метод  getAddress связан с кешем с именами адресов. Каждый раз, когда вызывается метод, кэш проверяется, чтобы увидеть, был ли вызов уже выполнен и не должен повторяться.

12.3 - @CachePut
Эта аннотация используется для методов. Всякий раз, когда вам нужно обновить кэш, не мешая выполнению метода, вы можете использовать  @CachePut  аннотацию. То есть метод всегда будет выполняться, а результат кэшируется.

12.4 - @CachePut("addresses")
public String getAddress(Book book){...}
Использование  @CachePut и @Cacheable использование одного и  того же метода категорически не рекомендуется, поскольку первый вызывает выполнение для выполнения обновления кэша, а последний вызывает пропуск метода с использованием кэша.

12.5 - @CacheEvict
Эта аннотация используется для методов. Дело не в том, что вы всегда хотите заполнять кеш все большим количеством данных. Иногда вам может понадобиться удалить некоторые данные из кэша, чтобы вы могли заполнить кэш некоторыми новыми значениями. В таком случае используйте  @CacheEvict аннотацию.

12.6 - @CacheEvict(value="addresses", allEntries="true")
public String getAddress(Book book){...}
Здесь, дополнительный элемент,  allEntriesиспользуется вместе с именем кэша, который должен быть очищен. Он имеет значение true, поэтому он очищает все значения и готовится к хранению новых данных.

12.7 - @CacheConfig
Эта аннотация является аннотацией на уровне класса. @CacheConfig Аннотаций позволяет упростить некоторые сведения о кэш — памяти на одном месте. Размещение этой аннотации в классе не включает никаких операций кэширования. Это позволяет хранить конфигурацию кеша на уровне класса, чтобы вам не приходилось объявлять что-либо несколько раз.


------------------------------------------ Выполнение задач и планирование аннотаций -----------------------------------

13.1 - @Scheduled
Эта аннотация является аннотацией уровня метода. @Scheduled Аннотаций используется на методах наряду с метаданными запуска. Метод с  @Scheduled должен иметь возвращаемый тип void и не должен принимать никаких параметров.

Существуют разные способы использования  @Scheduled аннотации:

@Scheduled(fixedDelay=5000)
public void doSomething() {
    // something that should execute periodically
}
В этом случае продолжительность между окончанием последнего выполнения и началом следующего выполнения является фиксированной. Задачи всегда ждут окончания предыдущего.

@Scheduled(fixedRate=5000)
public void doSomething() {
    // something that should execute periodically
}
В этом случае начало выполнения задачи не ожидает завершения предыдущего выполнения.

@Scheduled(initialDelay=1000,fixedRate=5000)
public void doSomething() {
   // something that should execute periodically after an initial delay
}
Задание сначала выполняется с задержкой, а затем продолжается с указанной фиксированной скоростью.

13.2 - @Async
Эта аннотация используется для методов для выполнения каждого метода в отдельном потоке. @Async Аннотаций предусмотрен на методе , так что вызов этого метода будет происходить асинхронно. В отличие от методов, помеченных как @Scheduled, методы, помеченные как,  @Async могут принимать аргументы. Они будут вызываться обычным способом вызывающими во время выполнения, а не по запланированной задаче.

 @Async может использоваться как с пустыми методами возвращаемого типа, так и с методами, возвращающими значение. Однако методы с возвращаемыми значениями должны иметь возвращаемое значение типа Future.


--------------------------------------- Spring Framework Аннотации для тестирования ------------------------------------

14.1 - @BootstrapWith
Эта аннотация является аннотацией на уровне класса. @BootstrapWith  Аннотаций используется для настройки , как Spring Framework TestContext загрузился. Эта аннотация используется в качестве метаданных для создания пользовательских аннотаций и уменьшения дублирования конфигурации в наборе тестов.

14.2 - @ContextConfiguration
Эта аннотация представляет собой аннотацию на уровне класса, которая определяет метаданные, используемые для определения, какие файлы конфигурации использовать для загрузки  ApplicationContext теста. Более конкретно,  @ContextConfiguration  объявляет аннотированные классы, которые будут использоваться для загрузки контекста. Вы также можете указать Spring, где найти файл.

@ContextConfiguration(locations={"example/test-context.xml", loader = Custom ContextLoader.class})
@WebAppConfiguration
Эта аннотация является аннотацией на уровне класса. @WebAppConfiguration  Используется для объявления о том , что  ApplicationContext загружен для испытания интеграции должно быть  WebApplicationContext. Эта аннотация используется для создания веб-версии контекста приложения. Важно отметить, что эта аннотация должна использоваться с  @ContextConfiguration  аннотацией. Путь к корню веб-приложения по умолчанию — src / main / webapp . Вы можете переопределить его, передав другой путь к <span class = «theme: classic lang: default decode: true crayon-inline»> @ WebAppConfiguration.

@Timed
Эта аннотация используется для методов. @Timed Аннотации указывает на то, что аннотированный метод испытания должен завершить свое выполнение в определенный период времени (в миллисекундах). Если выполнение превышает указанное время в аннотации, тест не пройден.

@Timed(millis=10000)
public void testLongRunningProcess() {  ... }
В этом примере тест не пройден, если он превышает 10 секунд выполнения.

@Повторение
Эта аннотация используется в методах испытаний. Если вы хотите запустить тестовый метод несколько раз подряд автоматически, вы можете использовать  @Repeat аннотацию. Количество раз, которое метод испытания должен быть выполнен, указано в аннотации.

@Repeat(10)
@Test
public void testProcessRepeatedly() {  ... }
В этом примере тест будет выполнен 10 раз.

@Commit
Эту аннотацию можно использовать как аннотацию как на уровне класса, так и на уровне метода. После выполнения тестового метода транзакция транзакционного метода может быть зафиксирована с использованием  @Commit аннотации. Эта аннотация явно передает цель кода. При использовании на уровне класса эта аннотация определяет фиксацию для всех методов тестирования в классе. Когда объявляется как аннотация уровня метода,  @Commit указывает фиксацию для определенных методов тестирования, переопределяющих фиксацию уровня класса.

@RollBack
Эта аннотация может использоваться как аннотация как на уровне класса, так и на уровне метода. @RollBack Аннотаций указывает , является ли транзакция транзакционной метода испытаний должен быть произведен откат после завершения проверки его исполнения. Если это правда,   @Rollback(true)транзакция откатывается. В противном случае транзакция совершается. @Commit  используется вместо   @RollBack(false).

При использовании на уровне класса эта аннотация определяет откат для всех методов тестирования в классе.

Когда объявляется как аннотация уровня метода,   @RollBack указывает откат для определенных методов тестирования, переопределяя семантику отката на уровне класса.

@DirtiesContext
Эта аннотация используется как аннотация как на уровне класса, так и на уровне метода. @DirtiesContext  указывает на то, что пружина  ApplicationContext была каким-либо образом изменена или повреждена и должна быть закрыта. Это вызовет перезагрузку контекста перед выполнением следующего теста. ApplicationContext помечается как грязный до или после любого такого аннотированного метода, а также до или после текущего класса тестирования.

В @DirtiesContext аннотации опоры   BEFORE_METHOD,   BEFORE_CLASSи  BEFORE_EACH_TEST_METHOD  режимы для закрытия  ApplicationContext перед тестом.

ПРИМЕЧАНИЕ . Избегайте чрезмерного использования этой аннотации. Это дорогостоящая операция, и в случае злоупотребления она может реально замедлить ваш набор тестов.

@BeforeTransaction
Эта аннотация используется для аннотирования пустых методов в тестовом классе. @BeforeTransaction  аннотированные методы указывают, что они должны быть выполнены до начала выполнения любой транзакции. Это означает, что метод, отмеченный с помощью,  @BeforeTransaction  должен быть выполнен до того, как какой-либо метод, отмеченный как   @Transactional.

@AfterTransaction
Эта аннотация используется для аннотирования пустых методов в тестовом классе. @AfterTransaction аннотированные методы указывают, что они должны быть выполнены после завершения транзакции для методов тестирования. Это означает, что метод, отмеченный с помощью,  @AfterTransaction  должен выполняться после метода, отмеченного с помощью   @Transactional.

@sql
Эта аннотация может быть объявлена ​​в тестовом классе или тестовом методе для запуска сценариев SQL для базы данных. @Sql  Аннотацию настраивает путь ресурсов для сценариев SQL , которые должны быть выполнены по отношению к данной базе данных либо до , либо после тестового метода интегрирования. Когда  @Sql используется на уровне метода, он переопределяет любой  @Sqldefined в уровне класса.

@SqlConfig
Эта аннотация используется вместе с  @Sql аннотацией. @SqlConfig Аннотаций определяет метаданные , которые используются для определения того, как анализировать и выполнять сценарии SQL , настроенные с помощью  @Sql  аннотаций. При использовании на уровне класса эта аннотация служит глобальной конфигурацией для всех сценариев SQL в тестовом классе. Но при использовании напрямую с атрибутом config   @Sql, он  @SqlConfig служит локальной конфигурацией для объявленных сценариев SQL.

@SqlGroup
Эта аннотация используется для методов. @SqlGroup Аннотаций представляет собой контейнер аннотации , который может содержать несколько  @Sql аннотаций. Эта аннотация может объявлять вложенные  @Sql аннотации.
Кроме того,  @SqlGroup используется в качестве метааннотации для создания пользовательских составных аннотаций. Эта аннотация также может использоваться вместе с повторяемыми аннотациями, где она  @Sql может быть объявлена ​​несколько раз для одного и того же метода или класса.

@SpringBootTest
Эта аннотация используется для запуска контекста Spring для интеграционных тестов. Это откроет полный контекст автоконфигурации.

@DataJpaTest
@DataJpaTest Аннотаций только обеспечивает необходимую автоконфигурацию для тестирования Spring Data JPA с использованием базы данных в оперативной памяти , такие как H2.

Эта аннотация используется вместо @SpringBootTest.

@DataMongoTest
Это  @DataMongoTest обеспечит минимальную автоконфигурацию и встроенную MongoDB для запуска интеграционных тестов с Spring Data MongoDB.

@WebMVCTest
Это  @WebMVCTest вызовет фиктивный контекст сервлета для тестирования уровня MVC. Сервисы и компоненты не загружаются в контекст. Чтобы предоставить эти зависимости для тестирования,  @MockBean  обычно используется аннотация.

@AutoConfigureMockMVC
@AutoConfigureMockMVC Аннотаций работает очень похоже на  @WebMVCTest аннотацию, но запускается полная весна загрузки контекста.

@MockBean
Создает и внедряет Mockito Mock для данной зависимости.

@JsonTest
Ограничит автоматическую настройку Spring Boot компонентами, относящимися к обработке JSON.

Это аннотации также автоконфигурирования экземпляра JacksonTester или GsonTester .

@TestPropertySource
Аннотация на уровне класса, используемая для указания источников свойств для тестового класса.


------------------------------------------- Spring Boot Annotations ----------------------------------------------------

@EnableAutoConfiguration
Эта аннотация обычно помещается в основной класс приложения.
@EnableAutoConfiguration  Аннотацию неявно определяет базу «поиск пакетов».
Эта аннотация говорит Spring Boot начинать добавление bean-компонентов на основе настроек пути к классам,
других bean-компонентов и различных настроек свойств.

@SpringBootApplication
Эта аннотация используется в классе приложения при настройке проекта Spring Boot.
Класс, помеченный знаком,  @SpringBootApplication  должен храниться в базовом пакете.
Единственное, что  @SpringBootApplication делает, — это компонентное сканирование.
Но он будет сканировать только свои подпакеты. Например, если вы поместите аннотированный класс  @SpringBootApplication в com.example,
он  @SpringBootApplication будет сканировать все его подпакеты, такие как com.example.a, com.example.b и com.example.ax.

Это  @SpringBootApplication  удобная аннотация, которая добавляет все следующее:
            @Configuration
            @EnableAutoConfiguration
            @ComponentScan